# 常见的垃圾回收方式

**一、引用计数**

* 对每个对象维护一个引用计数，当该对象被销毁时引用计数-1，当引用计数值为0时回收该对象
* 优点：对象很快被回收，不会出现内存耗尽或达到某个阈值才回收
* 缺点：不能很好处理循环引用（A引用B，B引用A），实时维护引用计数由一定代价
* 代表语言：Python、PHP、Swift

**二、标记-清除**

* 从根变量开始遍历所有引用的对象，引用的对象标记为“被引用”，没有被标记的进行回收
* 优点：解决了引用计数的缺点
* 缺点：需要STW（暂停程序运行）
* 代表语言：Golang（三色标记法）

**三、分代收集**

* 按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，生命周期短的放入新生代，不同代有不同的回收算法和回收频率
* 优点：回收性能好
* 缺点：算法复杂
* 代表语言：JAVA

# root

* golang首先标记root根对象，根对象的子对象也是存活的
* 根对象包括：全局变量，各个G stack变量

# 标记

* golang里span是内存管理的最小单位
* 通过gcmarkBits位图标记span的块是否被引用

<img src="./photo/标记.webp" style="zoom:80%;" />

# 三色标记法

**一、三色状态**

| 标记 | 状态                                                         |
| ---- | ------------------------------------------------------------ |
| 灰色 | 对象已被标记，但这个对象的子对象未标记                       |
| 黑色 | 对象已被标记，且对象的子对象也已标记gcmarkBits对应的位为1<br>（该对象不会被清理） |
| 白色 | 对象未被标记，gcmarkBits对应的位为0<br>（该对象将会在本次GC中被清理） |

**二、扫描标记规则**

| 标记 | 规则                                                         |
| ---- | ------------------------------------------------------------ |
| 灰色 | 扫描A时，如果A引用了B，则B为灰色（被引用变量）               |
| 黑色 | 1、扫描A时，如果A引用了B，则A为黑色（引用变量）<br>2、扫描A时，A没有引用其它对象，则A为黑色（引用的终点） |
| 白色 | 初始状态下所有对象都是白色                                   |

**三、三色标记扫描过程（广度优先搜索算法）**

* 开始时所有对象为白色
* 将所有**根对象**标记为灰色，放入队列
* 遍历灰色对象，将其标记为黑色，并将他们引用的对象标记为灰色，放入队列
* 重复步骤 *3* 持续遍历灰色对象，直至队列为空
* 此时只剩下黑色对象和白色对象，白色对象即为下一步需要清除的对象

<img src="./photo/三色标记过程与结果.png" style="zoom:80%;" />

**三、STW**

* 全称：`stop the world`
* 为了防止在标记过程中对象引用发生变化，导致清除仍在使用的对象，需要 STW进行锁定内存空间
* STW的带来了性能问题，需要停止所有的内存变化，即停止所有的goroutine，等待gc结束之后才恢复

**四、写屏障**

* GC的扫描和go代码可以同时运行, 但GC扫描的过程中go代码有可能改变了对象的引用
* 在标记的过程中，通过写屏障记录发生变化的指针，然后在 Mark termination 的 rescan 过程中，重新进行扫描，因为在这一步骤会 STW，所以在这一步骤完成后的白色对象，不会再被引用，可以直接清除
* **开启写屏障时需要开启STW暂存Stack依赖树**


# Go-GC

**一、Go-GC**

* Go的内存回收部分过程是并行运行的
* 整个GC流程需要进行两次`STW`（第一次是Stack scan阶段, 第二次是Mark Termination阶段）
* Go-GC由`Stack-Scan`、`Mark`、`Mark-Termination`和`Sweep`四个阶段组成

| 阶段             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| Stack scan       | 收集根对象，短暂开启STW用于启动写屏障                        |
| Mark             | 标记对象，直到标记完所有根对象（解决大部分对象的标记）       |
| Mark-Termination | 开启STW，重新扫描全局变量和引用发生变化的对象（写屏障），完成标记工作 |
| Sweep            | 并发清理标记为白色对象                                       |

<img src="./photo/1.18之前gc的流程.jpg" style="zoom: 50%;" />

**二、gc的触发条件**

| 条件 | 方式                                                      |
| ---- | --------------------------------------------------------- |
| 阈值 | 默认内存扩大一倍时启动gc                                  |
| 定期 | 默认2min触发一次gc（`src/runtime/proc.go:forcegcperiod`） |
| 手动 | runtime.gc()                                              |

**二、两次STW处理的事务**

* 第一次STW会准备根对象的扫描, 启动写屏障和辅助GC
* 第二次STW会重新扫描部分根对象和改变的对象, 禁用写屏障和辅助GC

# 版本迭代优化

* 1.8以后的golang将第一步的stop the world 也取消了
* 1.9开始, 写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间.

# 常见内存泄漏

**一、数组错误使用**

* 数组是值类型，传参时会复制一份副本给形参
* 并发场景下，数组过大时会导致内存使用激增

**二、Goroutine泄漏**

* Goroutine在执行时被阻塞而无法退出，就会导致Goroutine的内存泄漏
* 引起Goroutine的内存泄漏常见情况
  * 互斥锁未释放
  * 死锁
  * 读channel阻塞、写channel阻塞
* 定时器
  * time.Ticker是每隔指定的时间就会向通道内写数据。
  * 作为循环触发器，必须调用stop方法才会停止，从而被GC回收，否则会一直占用内存空间
* 切片的截取
  * 切片被截取引用时不会被gc回收，在并发情况下，如果原切片的数据利用率非常低会造成严重的内存泄露
  * 解决：向Goroutine输入切片时，需要将数据从原切片取出然后重新组装成新的切片
* 值类型传值
  * 向函数传递结构体数据时以值类型传值导致内存的泄露，值类型传递时只会传递副本
  * 解决：传递结构体数据时使用指针形式传递