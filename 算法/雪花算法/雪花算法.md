## 雪花算法

**一、雪花算法**

* 用于分布式唯一的ID生成
* 在分布式架构下，唯一序列生成在设计分库分表的时候常见的问题
* 常用于生成订单序号
* 雪花算法是推特开源的分布式ID生成算法，生成的ID是64位整型

**二、雪花算法的特点**

* 全局唯一不重复
* 序列递增，后面的ID比前面大
* 长度短提高查询效率
* 信息安全，ID不连续生成
* 高可用低延时，ID生成快，能用于高并发

## 推特开源雪花算法序列的划分

**一、序列的组成**

* 符号位（1位）

* 时间戳位：决定了算法生成ID的可用年限（41位）
* 工作进程位：决定了分布式系统的机器数（10位）
* 不碰撞序列的吞吐量：决定每毫秒单机系统可以生成的序列号（12位）

## 雪花算法的优缺点

**一、优点**

* 时间戳在高位，自增序列在低位，保证ID但是趋势递增
* 稳定性高，ID生成速度快，能用于高并发场景
* 实际应用时可以根据自身业务灵活分配bit位

**二、缺点**

* 依赖机器时钟，机器时钟回拨时可能会产生重复ID
* 分布式环境下每台机器的时钟不可能完全同步，可能出现不是全局递增的情况（时间戳在高位出现的问题）

## 解决单机系统中时钟回拨问题

**一、回拨时间短**

* 可以直接等待一定时间

**二、回拨时间长**

* 直接抛出异常
* RD时钟回滚

## 雪花算法的实现

**一、雪花结构体组成**

* 互斥锁：保证并发下的安全性
* 位移：通过位运算将数据移到正确的比特位上
* 序列：序列部分的初始值
* 最大值：要求每部分的数据不能超过最大值
* 上一次的时间戳：比较当前时间戳和上一次的时间戳，根据结果决定执行的方向

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

type SnowFlake struct {
	//-------------锁-------------------//
	//互斥锁
	Mutex sync.Mutex
	//----------外部输入的值-------------//
	MachineId int64
	//-----------每部分位移的位移---------//
	//时间戳的位移
	TimeStampShift int64
	//机器id的位移
	MachineIdShift int64
	//-----------每部分的最大值----------//
	TimeStampMax int64
	OrderMax     int64
	//-----------内部值------------------//
	//序列
	order int64
	//上次的时间戳
	LastTimeStamp int64
}

//构造方法
func getSnowHost(MachineId int64, TimeStampBit int64, MachineIdBit int64) (*SnowFlake, error) {
	//----------位移-------------------------------------//
	//时间戳位移
	TimeStampShift := 63 - TimeStampBit
	//机器id位移
	MachineIdShift := TimeStampShift - MachineIdBit
	if TimeStampShift < 0 || MachineIdShift < 0 {
		return nil, fmt.Errorf("bit位出错")
	}
	//--------------最值---------------------------------//
	//时间戳最大值
	TimeStampMax := int64(1<<TimeStampBit) - 1
	//机器Id最大值
	MachineIdMax := int64(1<<MachineIdBit) - 1
	//序列最大值
	OrderMax := int64(1<<(63-TimeStampBit-MachineIdBit)) - 1

	if MachineId > MachineIdMax {
		return nil, fmt.Errorf("机器id超出范围")
	}

	return &SnowFlake{MachineId: MachineId, TimeStampShift: TimeStampShift, MachineIdShift: MachineIdShift, TimeStampMax: TimeStampMax, OrderMax: OrderMax}, nil
}

func (s *SnowFlake) getUuid() (int64, error) {
	//加锁
	s.Mutex.Lock()
	defer s.Mutex.Unlock()
	//获取时间戳
	timeStamp := time.Now().UnixMilli()
	//校验时间戳范围
	if timeStamp > s.TimeStampMax {
		return 0, fmt.Errorf("时间戳超出范围")
	}
	//时间戳不同情况下的处理方式
	if timeStamp < s.LastTimeStamp {
		return 0, fmt.Errorf("时间回拨")
	} else if timeStamp == s.LastTimeStamp {
		s.order++
	} else {
		s.order = 0
	}
	//暂存时间戳
	s.LastTimeStamp = timeStamp
	//获取uuid并返回
	return timeStamp<<s.TimeStampShift | s.MachineId<<s.MachineIdShift | s.order, nil
}

func main() {
	obj, err := getSnowHost(1, 41, 10)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(obj)
	fmt.Println(obj.getUuid())
}
```





















